#+PROPERTY: header-args :tangle "~/.emacs.d/init.el"
* Frame
:PROPERTIES:
:header-args: :tangle "~/.emacs.d/early-init.el"
:END:
These options are added to ~early-init.el~ because they affect the initial frame, including dimensions, toolbars, etc.
Run fullscreen, and set a default font by adding values to ~default-frame-alist~ and ~initial-frame-alist~.
#+begin_src emacs-lisp
  (setq leanmc-default-font "Iosevka-20")
  (dolist (x
  	 `((fullscreen . fullboth)
  	   (font . ,leanmc-default-font)))
    (add-to-list 'default-frame-alist x)
    (add-to-list 'initial-frame-alist x))
#+end_src
I don't really use the startup screen, scroll bars, or tool bars. I keep the menus on in macOS because the menu bar doesn't disappear so I may as well fill it with stuff, even though I'll probably never use it.
#+begin_src emacs-lisp
  (setopt inhibit-startup-screen t)
  (if (not (eq system-type 'darwin)) (menu-bar-mode -1))
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
#+end_src
* Package manager
I am am using ~package.el~ for now.
#+begin_src emacs-lisp
  (require 'package)
#+end_src
Many useful packages are hosted on MELPA, so I add that to the sources.
#+begin_src emacs-lisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src
I also use ~use-package~, and especially appreciate its ability to ensure packages are installed when I load my config on a new machine or emacs installation.
#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setopt use-package-always-ensure t)
#+end_src
* Fonts
Set the ~fixed-pitch~ font to match the default.
#+begin_src emacs-lisp
  (set-face-font 'fixed-pitch leanmc-default-font)
#+end_src
Set the ~variable-pitch~ font.
#+begin_src emacs-lisp
  (set-face-font 'variable-pitch "CMU Serif-22")
#+end_src
In ~org-mode~, use ~variable-pitch-mode~.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'variable-pitch-mode)
  (add-hook 'org-agenda-mode-hook 'variable-pitch-mode)
#+end_src
* Completion and Search
Enable ~fido-vertical-mode~.
#+begin_src emacs-lisp
  (fido-vertical-mode 1)
#+end_src
Wrap around when selecting completion candidates.
#+begin_src emacs-lisp
  (setopt completion-auto-wrap t)
#+end_src
Display the ~*Completions*~ buffer when completion is requested and there is more than one candidate, keep it open thereafter, and update the list of completions on subsequent completion attempts.
#+begin_src emacs-lisp
  (setopt completion-auto-help 'visible)
#+end_src
Select the ~*Completions*~ buffer when tab is pressed after requesting completion.
#+begin_src emacs-lisp
  (setopt completion-auto-select 'second-tab)
#+end_src
Display candidates in a single column.
#+begin_src emacs-lisp
  (setopt completions-format 'one-column)
#+end_src
Display details for completion candidates.
#+begin_src emacs-lisp
  (setopt completions-detailed t)
#+end_src
Enable ~completion-preview-mode~ globally.
#+begin_src emacs-lisp
  (global-completion-preview-mode 1)
#+end_src
Display completion previews when one or more characters are typed.
#+begin_src emacs-lisp
  (setopt completion-preview-minimum-symbol-length 1)
#+end_src
Automatically close quotes, parentheses, etc.
#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src
Show the number of matches when using isearch.
#+begin_src emacs-lisp
  (setq isearch-lazy-count t)
#+end_src
* Keyboard and bindings
On macOS, I have found it useful to have the command key function as control, and option as meta. This way these commonly used keys are under my thumbs and I will hopefully not suffer RSI.
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setopt
     ns-command-modifier 'control
     ns-option-modifier 'meta
     ns-control-modifier 'super))
#+end_src
Have ~C-x C-b~ open up ~ibuffer~ instead of ~list-buffers~
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src
I find it intuitive to use ~<RET>~ to accept a ~completion-preview-mode~ candidate, ~<TAB>~ to complete up to the longest common prefix of all candidates (and summon the ~*Completions*~ buffer when pressed a second time), ~M-n~ and ~M-p~ to cycle through completion candidates.
#+begin_src emacs-lisp
  (define-key completion-preview-active-mode-map (kbd "<RET>") 'completion-preview-insert)
  (define-key completion-preview-active-mode-map (kbd "<TAB>") 'completion-preview-complete)
  (define-key completion-preview-active-mode-map (kbd "M-n") 'completion-preview-next-candidate)
  (define-key completion-preview-active-mode-map (kbd "M-p") 'completion-preview-prev-candidate)
#+end_src
Have ~C-c a~, ~C-c c~, and ~C-c l~ run ~org-agenda~, ~org-capture~, and ~org-store-link~, respectively.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c l") 'org-store-link)
#+end_src
* System bell
I find it much more effective and less annoying to have the modeline flash instead of the system beeping at me when I'm doing something silly.
#+begin_src emacs-lisp
  (defun flash-mode-line()
    (invert-face 'mode-line)
    (run-with-timer 0.1 nil #'invert-face 'mode-line))
  (setopt visible-bell nil
  	ring-bell-function 'flash-mode-line)
#+end_src
* Line modes and numbers
Always highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src
Use visual lines for numbering. Since I do a fair amount of writing long paragraphs with no line breaks, which results in multiple visual lines, I find this to be useful.
#+begin_src emacs-lisp
  (setopt display-line-numbers-type 'visual)
#+end_src
Use ~visual-line-mode~ in ~text-mode~, because it is common to have long blocks of text without line breaks in these modes.
#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'visual-line-mode)
#+end_src
Make sure the fringe is wide enough to cover all of the digits of the biggest line number right away.
#+begin_src emacs-lisp
  (setopt display-line-numbers-width-start t)
#+end_src
Always show line numbers...
#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
#+end_src
Except in ~org-mode~ (and agendas)
#+begin_src emacs-lisp
  (defun leanmc/disable-line-numbers() (display-line-numbers-mode -1))
  (add-hook 'org-mode-hook 'leanmc/disable-line-numbers)
  (add-hook 'org-agenda-mode-hook 'leanmc/disable-line-numbers)
#+end_src
* Theme
I'm currently using and enjoying ~modus-themes~, with italic and bold constructs, bold prompts, mixed fonts (for e.g. ~org-mode~), and easily distinguished heading sizes (for e.g. ~org-mode~).
#+begin_src emacs-lisp
  (setopt modus-themes-italic-constructs t
  	modus-themes-bold-constructs t
  	modus-themes-prompts '(bold)
  	modus-themes-mixed-fonts t
  	modus-themes-headings
  	'((5 . (1.1))
  	  (4 . (1.2))
  	  (3 . (1.3))
  	  (2 . (1.4))
  	  (1 . (1.5))))
#+end_src
Use ~auto-dark-emacs~ to automatically switch between ~modus-operandi~ and ~modus-vivendi~ in order to match the system's switching between light and dark themes which try to match... the sky.
#+begin_src emacs-lisp
  (use-package auto-dark)
  (setopt auto-dark-themes '((modus-vivendi-tinted) (modus-operandi-tinted)))
  (auto-dark-mode)
#+end_src
* Cursor
Always blink the cursor.
#+begin_src emacs-lisp
  (setopt blink-cursor-blinks 0)
#+end_src
This function first checks if we are in ~buffer-face-mode~, better known as ~variable-pitch-mode~. If so, it gets the face(s) at point. If there are none, then we are dealing with the ~variable-pitch~ face, so the bar cursor is used. If there's just one face, it pulls the ~:font~ attribute from that face and compares it with that of the ~fixed-pitch~ face. If the attributes match, we use the box face, otherwise the bar. Finally, if there are multiple faces, only one of them should have a ~:font~ attribute, so it finds that face and does the same thing as the single-face case.
#+begin_src emacs-lisp
  (defun leanmc/sync-cursor-type-with-pitch ()
    "Set the cursor-type to box when the font at point is fixed-pitch,
  and bar when it is variable pitch"
    (if buffer-face-mode
        (let ((face-points (get-text-property (point) 'face)))
  	(if (not face-points)
  	    (setq-local cursor-type 'bar)
  	  (if (not (listp face-points))
  	      (if (equal (face-attribute face-points :font nil t)
  			 (face-attribute 'fixed-pitch :font nil t))
  		  (setq-local cursor-type 'box)
  		(setq-local cursor-type 'bar))
  	    (dolist (face face-points)
  	      (if (fontp (face-attribute face :font nil t))
  		  (if (equal (face-attribute face :font nil t)
  			     (face-attribute 'fixed-pitch :font nil t))
  		      (setq-local cursor-type 'box)
  		    (setq-local cursor-type 'bar)))))))
      (setq-local cursor-type 'box)))
#+end_src
In ~org-mode~, run the above function any time the cursor moves (actually, this runs it any time the user runs a command).
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
  	  (lambda ()
  	    (add-hook 'post-command-hook 'leanmc/sync-cursor-type-with-pitch)))
#+end_src
* Icons
For pure aesthetics, I like having some icons. ~all-the-icons~ and its sub-packages are useful for this.
#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))
  (use-package all-the-icons-dired
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
  (use-package all-the-icons-ibuffer
    :after all-the-icons
    :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
  ;; disabled until they don't cause a blank completions buffer
  ;; https://github.com/iyefrat/all-the-icons-completion/issues/34#issue-3725535142
  ;; (use-package all-the-icons-completion
  ;;   :after all-the-icons
  ;;   :config (all-the-icons-completion-mode))
#+end_src
* Mode line
Here is a modified version of the function that formats right-aligned mode line content so that it (the function) takes the fringe into account.
#+begin_src emacs-lisp
  (defun mode--line-format-right-align ()
    "Right-align all following mode-line constructs.

  When the symbol `mode-line-format-right-align' appears in
  `mode-line-format', return a string of one space, with a display
  property to make it appear long enough to align anything after
  that symbol to the right of the rendered mode line.  Exactly how
  far to the right is controlled by `mode-line-right-align-edge'.

  It is important that the symbol `mode-line-format-right-align' be
  included in `mode-line-format' (and not another similar construct
  such as `(:eval (mode-line-format-right-align)').  This is because
  the symbol `mode-line-format-right-align' is processed by
  `format-mode-line' as a variable."
    (let* ((rest (cdr (memq 'mode-line-format-right-align
  			  mode-line-format)))
  	 (rest-str (format-mode-line `("" ,@rest)))
  	 (rest-width (progn
                         (add-face-text-property
                          0 (length rest-str) 'mode-line t rest-str)
                         (string-pixel-width rest-str))))
      (propertize " " 'display
  		;; The `right' spec doesn't work on TTY frames
  		;; when windows are split horizontally (bug#59620)
  		(if (and (display-graphic-p)
                           (not (eq mode-line-right-align-edge 'window)))
  		    `(space :align-to (- ,mode-line-right-align-edge
                                           (,rest-width)))
  		  `(space :align-to (,(- (window-pixel-width)
                                           (window-scroll-bar-width)
                                           (window-right-divider-width)
                                           (* (or (car (window-margins)) 0)
                                              (frame-char-width))
  					 (car (window-fringes))
                                           ;; Manually account for value of
                                           ;; `mode-line-right-align-edge' even
                                           ;; when display is non-graphical
                                           (pcase mode-line-right-align-edge
                                             ('right-margin
                                              (or (cdr (window-margins)) 0))
                                             ('right-fringe
                                              ;; what here?
                                              (or (cadr (window-fringes)) 0))
                                             (_ 0))
                                           rest-width)))))))
#+end_src
I have a custom modeline, with icons to indicate the major mode and file-edit status (unchanged, edited, or locked). I also include the buffer name and the current date and time. I have the edit status and buffer name on the left side, and the major mode with the date and time on the right.
#+begin_src emacs-lisp
  (setopt display-time-default-load-average nil
  	display-time-day-and-date t
  	display-time-format "%a %m/%d at %I:%M%p")
  (display-time)
  (line-number-mode -1)
  (let*
      ((modified-icon '(:eval
  		      (let* ((config-alist
                                '(("*" all-the-icons-faicon-family
  				 all-the-icons-faicon "chain-broken" :height 1.2 :v-adjust -0.0)
  				("-" all-the-icons-faicon-family
  				 all-the-icons-faicon "link" :height 1.2 :v-adjust -0.0)
  				("%" all-the-icons-octicon-family
  				 all-the-icons-octicon "lock" :height 1.2 :v-adjust 0.1)))
  			     (result (cdr (assoc (format-mode-line "%*") config-alist))))
  			(propertize (apply (cadr result) (cddr result))
  				    'face `(:family ,(funcall (car result)))))))
       (mode-icon '(:eval (propertize (all-the-icons-icon-for-mode major-mode)
  				    'help-echo (format "Major-mode: %s" major-mode)
  				    'local-map mode-line-major-mode-keymap)))
       (pos '(-3 "%p")))
    (setq-default mode-line-format `(" "
  				   ,modified-icon
  				   " "
  				   ,pos
  				   " of "
  				   ,mode-line-buffer-identification
  				   " "
  				   mode-line-format-right-align
  				   ,mode-icon
  				   " "
  				   ,mode-line-misc-info
  				   " ")))
#+end_src
* Dired
Hide the details in ~dired~, I find them more overwhelming than useful.
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src
* Org mode
Sometimes I only have one hand available and mouse support is nice.
#+begin_src emacs-lisp
  (require 'org-mouse)
#+end_src
Adding on to prettification: use ~olivetti-mode~.
#+begin_src emacs-lisp
  (use-package olivetti)
  (setopt olivetti-body-width 0.7)
  (setopt olivetti-style 'fancy)
  (add-hook 'org-mode-hook 'olivetti-mode)
  (add-hook 'org-agenda-mode-hook 'olivetti-mode)
#+end_src
I use one big ~org~ file for everything, thus use that file as my ~org-agenda-files~.
#+begin_src emacs-lisp
  (setopt org-agenda-files '("~/Dropbox/org/life.org"))
#+end_src
Start up folded.
#+begin_src emacs-lisp
  (setopt org-startup-folded 'fold)
#+end_src
When ~<TAB>~ is pressed somewhere other than a headline, don't run ~org-cycle~.
#+begin_src emacs-lisp
  (setopt org-cycle-emulate-tab t)
#+end_src
When ~<RET>~ or ~<TAB>~ is pressed and the cursor is over a link, follow it.
#+begin_src emacs-lisp
  (setopt org-return-follows-link t
  	org-tab-follows-link t)
#+end_src
Don't show the markup, show the end result.
#+begin_src emacs-lisp
  (setopt org-hide-emphasis-markers t)
#+end_src
Here I specify some helpful ~TODO~ keywords. I mostly just track state changes with timestamps. When a ~TODO~ needs to ~WAIT~, prompt for a note, and don't track anything when appointments were marked as ~COMP~ (completed).
#+begin_src emacs-lisp
  (setopt org-todo-keywords
  	'((sequence "TODO(t!)" "WAIT(@)" "|" "DONE(d!)")
  	  (sequence "SCHE(s!)" "|" "COMP(c!)" "CANC(n@)")
  	  (sequence "OWED(o!)" "|" "PAID(p!)")))
#+end_src
Here is some code, modified from [[https://fuco1.github.io/2017-09-02-Maximize-the-org-capture-buffer.html][this example]], that stores the window configuration, deletes other windows while an ~org-capture~ buffer is active, then restores the window configuration after the capture is finalized.
#+begin_src emacs-lisp
  (defvar leanmc/window-config nil
    "Window configuration.")

  (defun leanmc/org-capture--save-config (activate)
    "Save the window configuration before `org-capture'."
    (setq leanmc/window-config (current-window-configuration)))

  (advice-add 'org-capture :before #'leanmc/org-capture--save-config)

  (add-hook 'org-capture-mode-hook 'delete-other-windows)

  (defun leanmc/org-capture--cleanup ()
    "Restore the old window config."
    (when leanmc/window-config
      (set-window-configuration leanmc/window-config)))

  (add-hook 'org-capture-after-finalize-hook 'leanmc/org-capture--cleanup)
#+end_src
I use a small handful of ~org-capture~ templates.
#+begin_src emacs-lisp
  (setopt org-default-notes-file (car org-agenda-files))
  (setq org-capture-templates
        '(
          ("j" "Journal" entry (file+olp+datetree "" "journal") "* %<%l:%M%p>\n%?")
          ("w" "Add a work item")
          ("wc" "Add class plans" plain (file+olp+datetree "" "work" "current year" "class plans") "\n%?" :time-prompt t)
          ("wp" "Add PD notes" plain (file+olp+datetree "" "work" "current year" "pd notes") "\n%?")
  	("wa" "Add a work appointment" entry (file+olp "" "work" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("wt" "Add a work todo" entry (file+olp "" "work" "todos") "* TODO %?\n- State \"TODO\"\n%U")
  	("p" "Add a parenting item")
  	("pa" "Schedule a parenting appointment" entry (file+olp "" "parenting" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("pt" "Add a parenting todo" entry (file+olp "" "parenting" "todos") "* TODO %?\n- State \"TODO\"\n%U")
  	("g" "Add an item to a grocery list")
          ("gc" "Add an item to the Costco grocery list" checkitem (file+headline "" "Costco") "[ ] %?")
          ("gt" "Add an item to the Target grocery list" checkitem (file+headline "" "Target") "[ ] %?")
          ("ga" "Add an item to the Amazon grocery list" checkitem (file+headline "" "Amazon") "[ ] %?")
          ("gj" "Add an item to the TJs grocery list" checkitem (file+headline "" "TJs") "[ ] %?")
          ("gs" "Add an item to the Safeway grocery list" checkitem (file+headline "" "Safeway") "[ ] %?")
          ("go" "Add an item to the Other grocery list" checkitem (file+headline "" "Other") "[ ] %?")
  	("h" "Add a health item")
  	("ha" "Schedule a health appointment" entry (file+olp "" "health" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("ht" "Add a health todo" entry (file+olp "" "health" "todos") "* TODO %?\n- State \"TODO\"\n%U")
  	("f" "Add a financial item")
  	("fd" "Add a new debt" entry (file+olp "" "finances" "debts") "* OWED %?\n- State \"OWED\"\n%U")
          ("fa" "Schedule a financial appointment" entry (file+olp "" "finances" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("ft" "Add a financial todo" entry (file+olp "" "finances" "todos") "* TODO %?\n- State \"TODO\"\n%U")
  	("l" "Add a legal item")
  	("la" "Schedule a legal appointment" entry (file+olp "" "legal" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("lt" "Add a legal todo" entry (file+olp "" "legal" "todos") "* TODO %?\n- State \"TODO\"\n%U")
  	("h" "Add a home item")
  	("ha" "Schedule a home appointment" entry (file+olp "" "home" "appointments") "* SCHE %?\nSCHEDULED: %^T")
  	("ht" "Add home todo" entry (file+olp "" "home" "todos") "* TODO %?\n- State \"TODO\"\n%U")))
#+end_src
Have ~org-agenda-list~ start from today, rather than Monday.
#+begin_src emacs-lisp
  (setopt org-agenda-start-on-weekday nil)
#+end_src
Icons instead of category names.
#+begin_src emacs-lisp
  (setopt org-agenda-category-icon-alist
  	`(("parenting" ,(list (all-the-icons-faicon "users" :width 2)))
  	  ("health" ,(list (all-the-icons-faicon "heart" :width 2)))
  	  ("work" ,(list (all-the-icons-faicon "briefcase" :width 2)))
  	  ("legal" ,(list (all-the-icons-faicon "gavel" :width 2)))
  	  ("finances" ,(list (all-the-icons-faicon "usd" :width 2)))
  	  ("home" ,(list (all-the-icons-faicon "home" :width 2)))))
  (setopt org-agenda-prefix-format '((agenda . " %i %?-12t") (todo . " %i ")
  				   (tags . " %i ") (search . " %i ")))
#+end_src
In the list of todos, ignore ones that will show up in the agenda anyway.
#+begin_src emacs-lisp
  (setopt org-deadline-warning-days 7)
  (setopt org-agenda-todo-ignore-deadlines 'near)
  (setopt org-agenda-todo-ignore-scheduled 'all)
#+end_src
Start emacs with the agenda and todo list.
#+begin_src emacs-lisp
  (defun emacs-startup-screen ()
    "Display the weekly org-agenda and all todos."
    (org-agenda nil "n"))
  (add-hook 'emacs-startup-hook #'emacs-startup-screen)
#+end_src
Run the agenda with no other windows, but restore other windows when done.
#+begin_src emacs-lisp
  (setopt org-agenda-window-setup 'only-window)
  (setopt org-agenda-restore-windows-after-quit t)
#+end_src
When refiling, these options enable me to get to basically any location I want, with completion.
#+begin_src emacs-lisp
  (setopt org-refile-targets '((org-agenda-files :maxlevel . 9))
  	org-refile-use-outline-path t
  	org-outline-path-complete-in-steps nil)
#+end_src
I find it convenient for properties to be inherited. Especially for export!
#+begin_src emacs-lisp
  (setopt org-use-property-inheritance t)
#+end_src
More often than not, I /don't/ want to export a TOC, the date, section numbers, or my name. I /do/ like smart quotes.
#+begin_src emacs-lisp
  (setopt org-export-with-toc nil)
  (setopt org-export-with-date nil)
  (setopt org-export-with-author nil)
  (setopt org-export-with-section-numbers nil)
  (setopt org-export-with-smart-quotes t)
#+end_src
I am just geting started with ~ox-hugo~, and hope to use it to publish hopefully useful things on the web.
#+begin_src emacs-lisp
  (use-package ox-hugo
    :pin melpa
    :after ox)
#+end_src
Here I set some options to make math snippets load automatically and also look nice.
#+begin_src emacs-lisp
  (setopt org-startup-with-latex-preview t)
  (setopt org-preview-latex-default-process 'dvisvgm)
  (setopt org-format-latex-options (plist-put org-format-latex-options :scale 2.5))
#+end_src
* Latex
I find ~auctex~ and ~latex-preview-pane~ to be very useful when I'm typesetting.
#+begin_src emacs-lisp
  (use-package auctex)
  (use-package latex-preview-pane)
#+end_src
* Ledger
I love ~ledger-mode~ for keeping track of my finances. It's truly fantastic, and has great integration with ~org-mode~.
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode ("\\.dat\\'"
  	 "\\.ledger\\'"))
#+end_src
* Magit
I am no coder, but I do use version control to track this file. Maybe I'll use it for other stuff later.
#+begin_src emacs-lisp
  (setq auth-sources '("~/.authinfo"))
  (use-package magit)
#+end_src
* ERC
These options make ERC somewhat functional for basic IRC usage. I don't use IRC much, but it's nice to get help with, oh say, my emacs config, for example. Some day I'll figure out how to properly store my credentials, but for now I just edit the tangled file.
#+begin_src emacs-lisp
  (setopt erc-modules
  	'(autojoin
  	  button
  	  completion
  	  fill
  	  irccontrols
  	  list
  	  match
  	  menu
  	  move-to-prompt
  	  netsplit
  	  networks
  	  noncommands
  	  notifications
  	  readonly
  	  ring
  	  sasl
  	  spelling
  	  stamp
  	  track)
  	erc-autojoin-channels-alist
  	'(("libera.chat" "#emacs"))
  	erc-autojoin-timing 'ident
  	erc-hide-list
  	'("JOIN" "PART" "QUIT")
  	erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
  				  "324" "329" "332" "333" "353" "477")
  	erc-sasl-nick "nick"
  	erc-sasl-user "user"
  	erc-sasl-password "a_password"
  	erc-server-auth-method 'sasl)
#+end_src
* Startup screen
Run ~org-agenda~
#+begin_src emacs-lisp
  (org-agenda-list)
#+end_src
